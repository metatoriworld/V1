<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MetaToRI ‚Äî Emotional Star Field</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      overflow:hidden;
      background:#000010;
      font-family:"Pretendard", system-ui, sans-serif;
      color:#fff;
    }
    canvas {
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }
  </style>
</head>
<body>
  <canvas id="universe"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    const canvas = document.getElementById("universe");
    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 6000);
    camera.position.set(0, 0, 9);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);

    // üåç ÏßÄÍµ¨
    const loader = new THREE.TextureLoader();
    const earthDay = loader.load("https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg");
    const earthNight = loader.load("https://threejs.org/examples/textures/planets/earth_at_night_2048.jpg");
    const earthMat = new THREE.MeshPhongMaterial({
      map: earthDay,
      emissiveMap: earthNight,
      emissive: 0x222244,
      emissiveIntensity: 2.2,
      shininess: 35
    });
    const earth = new THREE.Mesh(new THREE.SphereGeometry(1, 64, 64), earthMat);
    earth.position.set(0, -1.2, 0);
    scene.add(earth);

    // üí° Ï°∞Î™Ö
    const sunLight = new THREE.PointLight(0xffffff, 3, 0, 2);
    sunLight.position.set(5, 3, 6);
    const ambient = new THREE.AmbientLight(0x404070, 0.8);
    scene.add(sunLight, ambient);

    // üåå Î∞∞Í≤Ω Î≥Ñ
    const starCount = 7000;
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(starCount * 3);
    const starColor = new Float32Array(starCount * 3);
    const temp = new THREE.Color();
    for (let i = 0; i < starCount; i++) {
      const r = 400 + Math.random() * 1200;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos((Math.random() * 2) - 1);
      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.sin(phi) * Math.sin(theta);
      const z = r * Math.cos(phi);
      starPos[i*3] = x; starPos[i*3+1] = y; starPos[i*3+2] = z;

      const hue = 0.55 + Math.random() * 0.12;
      temp.setHSL(hue, 0.6, 0.85 + Math.random()*0.1);
      starColor[i*3] = temp.r; starColor[i*3+1] = temp.g; starColor[i*3+2] = temp.b;
    }
    starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
    starGeo.setAttribute("color", new THREE.BufferAttribute(starColor, 3));
    const starMat = new THREE.PointsMaterial({
      vertexColors:true, size:1.6, transparent:true, opacity:0.9,
      blending:THREE.AdditiveBlending,
      map:loader.load("https://threejs.org/examples/textures/sprites/circle.png")
    });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // üåà Í∞êÏ†ï ÏÉâÏÉÅ
    const emotionColors = [0xffd700, 0x4b9eff, 0xff4b4b, 0x9effa0, 0xff80c1, 0xb388ff, 0x00ffff];
    const haloTex = loader.load("https://threejs.org/examples/textures/lensflare/lensflare0.png");

    // üå† Î≥ÑÏûêÎ¶¨ (40Í∞ú)
    const constellations = [];
    const constellationCount = 40;
    const baseRadius = 2.8;

    for (let i = 0; i < constellationCount; i++) {
      const group = new THREE.Group();
      const color = emotionColors[i % emotionColors.length];
      const starCount = 6 + Math.floor(Math.random() * 4);
      const starsInGroup = [];

      const thetaBase = Math.random() * Math.PI * 2;
      const phiBase = Math.acos((Math.random() * 2) - 1);

      for (let j = 0; j < starCount; j++) {
        const theta = thetaBase + (Math.random() - 0.5) * 0.4;
        const phi = phiBase + (Math.random() - 0.5) * 0.25;
        const radius = baseRadius + Math.random() * 0.8;
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);

        const core = new THREE.Mesh(
          new THREE.SphereGeometry(0.05, 16, 16),
          new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.95 })
        );
        const halo = new THREE.Sprite(new THREE.SpriteMaterial({
          map: haloTex, color, transparent:true, opacity:0.5, blending:THREE.AdditiveBlending
        }));
        halo.scale.set(0.4, 0.4, 1);
        core.add(halo);
        core.position.set(x, y, z);
        group.add(core);
        starsInGroup.push(core);
      }

      for (let k = 0; k < starsInGroup.length - 1; k++) {
        const p1 = starsInGroup[k].position;
        const p2 = starsInGroup[k+1].position;
        const lineGeo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
        const lineMat = new THREE.LineBasicMaterial({
          color, opacity:0.4, transparent:true, blending:THREE.AdditiveBlending
        });
        group.add(new THREE.Line(lineGeo, lineMat));
      }

      scene.add(group);
      constellations.push({ group, stars: starsInGroup });
    }

    // üé• Ïï†ÎãàÎ©îÏù¥ÏÖò
    function animate(t){
      requestAnimationFrame(animate);
      const time = t * 0.001;

      // ÏßÄÍµ¨ÏôÄ Î≥ÑÏù¥ Í∞ôÏùÄ Î∞©Ìñ•ÏúºÎ°ú ÌöåÏ†Ñ
      earth.rotation.y += 0.0006;
      stars.rotation.y += 0.0006;

      // Ïπ¥Î©îÎùºÍ∞Ä Ï≤úÏ≤úÌûà ÌöåÏ†ÑÌïòÎ©¥ÏÑú Í±∞Î¶¨Í∞ê ÏÉùÏÑ±
      const camZ = 9 + Math.sin(time * 0.1) * 0.8;
      camera.position.z = camZ;
      camera.position.x = Math.sin(time * 0.05) * 0.5;
      camera.position.y = Math.sin(time * 0.04) * 0.3;
      camera.lookAt(0, 0, 0);

      // Ïπ¥Î©îÎùº Í±∞Î¶¨ Í∏∞Î∞òÏúºÎ°ú Î≥Ñ ÌÅ¨Í∏∞ Î≥ÄÌôî (Î©ÄÏñ¥ÏßàÏàòÎ°ù ÏûëÏïÑÏßê)
      const scaleFactor = THREE.MathUtils.mapLinear(camZ, 8.2, 9.8, 1.3, 0.9);
      starMat.size = 1.6 * scaleFactor;

      constellations.forEach((c)=>{
        // Î≥ÑÏûêÎ¶¨ Í∑∏Î£πÏù¥ ÏßÄÍµ¨ÏôÄ Ìï®Íªò ÌöåÏ†Ñ
        c.group.rotation.y += 0.0006;
        c.group.rotation.x = Math.sin(time * 0.03) * 0.2;
        c.group.scale.set(scaleFactor, scaleFactor, scaleFactor);

        // Î≥Ñ Î∞òÏßùÏûÑ Ìö®Í≥º
        c.stars.forEach((s,i)=>{
          const pulse = 0.5 + 0.5*Math.sin(time*0.6+i*0.4);
          s.material.opacity = 0.4 + pulse*0.5;
          if(s.children[0]){
            s.children[0].material.opacity = 0.3 + pulse*0.4;
            const sc = 0.25 + pulse * 0.1 * scaleFactor;
            s.children[0].scale.set(sc, sc, 1);
          }
        });
      });

      renderer.render(scene,camera);
    }
    animate();

    window.addEventListener("resize",()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
